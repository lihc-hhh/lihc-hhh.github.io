<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<meta name="hexo-config" content="{&quot;hostname&quot;:&quot;lihc-hhh.github.io&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://lihc-hhh.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LHC">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lihc-hhh.github.io/">



<meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;}">
<meta name="hexo-config-calendar" content="">
<script data-pjax src="/js/load-config.js"></script>
  <title>Hexo</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LHC</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lihc-hhh.github.io/2021/04/19/TexStudio%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E5%87%BA%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LHC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/19/TexStudio%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E5%87%BA%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-19 21:28:44 / 修改时间：21:27:52" itemprop="dateCreated datePublished" datetime="2021-04-19T21:28:44+08:00">2021-04-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><h1 id="TexStudio编译参考文献"><a href="#TexStudio编译参考文献" class="headerlink" title="TexStudio编译参考文献"></a>TexStudio编译参考文献</h1><p>前几天在写论文时遇到了TexStudio无法编译出参考文献的问题，明明使用的默认的模板，几经周折，找到了正确且有效的解决方法。当然找的过程也遇到了一些**(脏话)的无脑转载误人子弟。</p>
<p>前提：论文文件是<strong>main.tex</strong>, 参考文献文件 是<strong>main.bib</strong>。这<strong>两个文件要放在同一个文件夹下</strong>。main只是文件名，这个不影响，不过这两个文件<strong>必须放在同一个文件夹下</strong>。</p>
<p>如果不会创建bib文件，可以先创建text文件，之后再修改后缀名即可。</p>
<p><strong>正文开始</strong></p>
<p>TexStudio要想编译出参考文献须满足下列几个条件</p>
<ul>
<li><p>bib中的文献在论文中要有引用 ，如果没有引用，只放在bib文件中是无法编译出的。</p>
<p> 引用方式如下</p>
</li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\cite</span>&#123;放入文献的内容&#125;</span><br><span class="line"></span><br><span class="line">一般都用Bibtex格式</span><br><span class="line">这是一个bibtex格式的一篇论文引用，要想正确引用，就要使用</span><br><span class="line"><span class="keyword">\cite</span>&#123;2014LFD&#125;</span><br><span class="line"></span><br><span class="line">@inproceedings&#123;2014LFD,</span><br><span class="line">	title=&#123;LFD: Lost and found dog application on mobile&#125;,</span><br><span class="line">	author=&#123; Chutichudet, S.  and  Kanthathasiri, T.  and  Ritsakunchai, I.  and D Wongsawang&#125;,</span><br><span class="line">	booktitle=&#123;Student Project Conference&#125;,</span><br><span class="line">	year=&#123;2014&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cite引用一般是跟在正文的文字后面</span><br><span class="line">这样才能进行下一步</span><br></pre></td></tr></table></figure>

<ul>
<li>在合适的正文段落后面加上cite引用后，就是要执行正确的编译阶段了。由于要编译bib文件，所以要按顺序编译。</li>
<li>正确的编译顺序操作就是 <ul>
<li>按F6即可编译tex文件</li>
<li>按F8即可编译bib文件</li>
</ul>
</li>
<li>按顺序执行完上述两步编译后，你的参考文献就会出现在你的论文中了。</li>
<li>此操作不需要引用任何包！</li>
<li>我在写论文的时候就深受texstudio无法编译出参考文献的苦恼，百度了很久，只有一些<strong>极其不负责任</strong>的博主在转载同一篇文章，丝毫没有细节可言。</li>
<li>他们在文章中提到的解决方法就是<ul>
<li>LaTeX编译</li>
<li>BibTex编译</li>
<li>LaTeX编译</li>
<li>LaTeX编译</li>
</ul>
</li>
<li>但他们只是<strong>无脑转载</strong>，不提供具体的操作方法</li>
<li>所以如果你使用了本方法解决了你的问题，就是我最大的幸运！</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lihc-hhh.github.io/2021/04/04/java-%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LHC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/java-%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">java-异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-04 16:47:17 / 修改时间：16:50:01" itemprop="dateCreated datePublished" datetime="2021-04-04T16:47:17+08:00">2021-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java-线程池"></a>Java-线程池</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>创建线程要花费昂贵的资源和时间，如果任务来了才创建那么响应时间就会变成，而且一个进程创建的线程数有限</li>
<li>线程池就是首先创建一些线程，它们的集合成为<strong>线程池</strong>，线程池在系统启动时即创建大量空闲线程，程序将一个任务传给线程池，线程池就会启动一条线程执行这个任务，执行结束后，线程并不会死亡，而是再次返回线程池中成为空闲状态</li>
</ul>
<hr>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>降低资源消耗，通过重复利用已创建的线程降低创建和销毁的花费</li>
<li>提高响应速度，任务可以不需要等到线程创建就能立即执行</li>
<li>提高线程可管理性，使用线程池可以统一分配，调优和监控</li>
</ul>
<hr>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,milliseconds,runnableTaskQueue,handler);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>corePoolSize: 线程池基本大小</strong>，当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，(除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。)<br>&nbsp;</p>
</li>
<li><p><strong>maximumPoolSize: 线程池所允许的最大线程个数</strong>。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。对于无界队列，可忽略该参数。</p>
</li>
<li><p><strong>keepAliveTime: 线程存活时间</strong>，当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</p>
</li>
<li><p><strong>runnableTaskQueue: 任务队列</strong>，用于传输和保存等待执行任务的阻塞队列</p>
<ul>
<li>ArrayBlockingQueue: <strong>基于数组结构的有界阻塞队列</strong>，FIFO先进先出排序</li>
<li>LinkedBlockingQueue: <strong>基于链表结构的阻塞队列</strong>，FIFO排序，吞吐量高于ArrayBlockingQueue，静态工厂方法</li>
<li>SynchronousQueue: <strong>不存储元素的阻塞队列</strong>，每个插入必须等到另一个进程调用移除操作，否则插入一直处于阻塞状态; 吞吐量高于LinkedBlockingQueue</li>
<li>PriorityBlockingQueue: 具有<strong>优先级的无界阻塞队列</strong></li>
</ul>
</li>
<li><p><strong>threadFactory: 线程工厂</strong>，用于<strong>创建新线程</strong>，threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n(m为线程池的编号，n为线程池内的线程编号)。</p>
</li>
<li><p><strong>handler: 线程饱和策略</strong>，当任务太多来不及处理时，用于拒绝任务，实现了RejectedExecutionHandler接口</p>
<ul>
<li><strong>AbortPolicy</strong>: 直接抛出异常，阻止系统正常运行</li>
<li><strong>CallerRunsPolicy</strong>: 直接在调用者线程中，运行当前被丢弃的任务</li>
<li><strong>DiscardOlderPolicy</strong>: 丢弃最老的一个请求，并执行当前任务</li>
<li><strong>DiscardPolicy</strong>: 丢弃无法处理的任务，不予任何处理</li>
</ul>
</li>
</ul>
<hr>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/6024478-88ee7b20f8f45825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/937/format/webp" alt="avator"></p>
<ul>
<li>首先判断<strong>基本线程池</strong>是否已满，未满则创建一个工作线程执行任务，满了则下一步</li>
<li>线程池判断<strong>工作队列</strong>是否已满，未满则将新提交的任务存储到工作队列中，满了则下一步</li>
<li>线程池判断<strong>整个线程池</strong>是否已满，未满则创建新的工作线程执行任务，满了则交给饱和策略处理</li>
</ul>
<hr>
<h3 id="线程池提交"><a href="#线程池提交" class="headerlink" title="线程池提交"></a>线程池提交</h3><ul>
<li>使用execute提交，没有返回值</li>
<li>使用submit提交，会<strong>返回一个future</strong>，通过future.get()获取，<strong>阻塞直到任务执行完</strong>，而get(long timeout,TimeUnit,unit)方法则<strong>会阻塞一段时间后</strong>立即返回<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Object s = future.get();</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">    <span class="comment">//处理中断异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">    <span class="comment">//处理无法执行任务异常</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    executo.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><ul>
<li>调用线程<strong>shutdown或shutdownNow</strong>方法，遍历线程池中的的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止</li>
<li>区别在于: <strong>shutdownNow将线程池的状态设为STOP</strong>，然后<strong>尝试停止所有的正在执行或暂定任务的线程，并返回等待执行任务的列表</strong>; 而<strong>shutdown是将线程池的状态设为SHUTDOWN状态</strong>，然后中断所有没有正在执行任务的线程</li>
<li>只要调用了两个方法中的任意一个，<strong>isShutdown方法就会返回true</strong>，而所有的任务都已关闭即所有的线程池关闭，<strong>isTerminated才会返回true</strong></li>
</ul>
<hr>
<h3 id="线程池的配置"><a href="#线程池的配置" class="headerlink" title="线程池的配置"></a>线程池的配置</h3><ul>
<li>任务性质<ul>
<li>CPU密集型任务: 尽量使用较小的线程池，核心数+1，若开过多的线程池，会造成CPU过度切换</li>
<li>IO密集型任务: 使用稍大的线程池，核心数*2，IO密集型CPU使用率不高，因此CPU在等待IO时有其它线程处理其它任务</li>
<li>混合型任务: 可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理</li>
</ul>
</li>
<li>任务优先级: 高，中，低</li>
<li>任务执行时间: 长，中，短</li>
<li>任务依赖性: 是否依赖其他系统资源，如数据库连接</li>
</ul>
<hr>
<h3 id="Java提供的线程池"><a href="#Java提供的线程池" class="headerlink" title="Java提供的线程池"></a>Java提供的线程池</h3><ul>
<li><strong>newCachedThreadPool</strong>：用来创建一个<strong>可以无限扩大</strong>的线程池，适用于<strong>负载较轻</strong>的场景，执行短期异步任务。(可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换)</li>
<li><strong>newFixedThreadPool</strong>：创建一个<strong>固定大小</strong>的线程池，因为采用<strong>无界的阻塞队列</strong>，所以实际线程数量永远不会变化，适用于<strong>负载较重</strong>的场景，对当前线程数量进行限制。(保证线程数可控，不会造成线程过多，导致系统负载更为严重)</li>
<li><strong>newSingleThreadExecutor</strong>：创建一个<strong>单线程</strong>的线程池，适用于需要保证顺序执行各个任务</li>
<li><strong>newScheduledThreadPool</strong>：适用于<strong>执行延时或者周期性任务</strong></li>
</ul>
<hr>
<h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><ul>
<li><strong>taskCount</strong>: 线程池需要执行的任务数量</li>
<li><strong>completedTaskCount</strong>: 已完成的任务数量，小于等于taskCount</li>
<li><strong>largestPoolSize</strong>: 曾经创建过的最大线程数量，可以判断线程池是否满过</li>
<li><strong>getPoolSize</strong>: 线程池线程数量，若线程池不销毁的话，线程不会自动销毁</li>
<li><strong>getActiveCount</strong>: 获取活动的线程数 </li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lihc-hhh.github.io/2021/04/04/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LHC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">Java-线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-04 16:47:02 / 修改时间：16:49:52" itemprop="dateCreated datePublished" datetime="2021-04-04T16:47:02+08:00">2021-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java-线程池"></a>Java-线程池</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>创建线程要花费昂贵的资源和时间，如果任务来了才创建那么响应时间就会变成，而且一个进程创建的线程数有限</li>
<li>线程池就是首先创建一些线程，它们的集合成为<strong>线程池</strong>，线程池在系统启动时即创建大量空闲线程，程序将一个任务传给线程池，线程池就会启动一条线程执行这个任务，执行结束后，线程并不会死亡，而是再次返回线程池中成为空闲状态</li>
</ul>
<hr>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>降低资源消耗，通过重复利用已创建的线程降低创建和销毁的花费</li>
<li>提高响应速度，任务可以不需要等到线程创建就能立即执行</li>
<li>提高线程可管理性，使用线程池可以统一分配，调优和监控</li>
</ul>
<hr>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,milliseconds,runnableTaskQueue,handler);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>corePoolSize: 线程池基本大小</strong>，当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，(除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。)<br>&nbsp;</p>
</li>
<li><p><strong>maximumPoolSize: 线程池所允许的最大线程个数</strong>。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。对于无界队列，可忽略该参数。</p>
</li>
<li><p><strong>keepAliveTime: 线程存活时间</strong>，当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</p>
</li>
<li><p><strong>runnableTaskQueue: 任务队列</strong>，用于传输和保存等待执行任务的阻塞队列</p>
<ul>
<li>ArrayBlockingQueue: <strong>基于数组结构的有界阻塞队列</strong>，FIFO先进先出排序</li>
<li>LinkedBlockingQueue: <strong>基于链表结构的阻塞队列</strong>，FIFO排序，吞吐量高于ArrayBlockingQueue，静态工厂方法</li>
<li>SynchronousQueue: <strong>不存储元素的阻塞队列</strong>，每个插入必须等到另一个进程调用移除操作，否则插入一直处于阻塞状态; 吞吐量高于LinkedBlockingQueue</li>
<li>PriorityBlockingQueue: 具有<strong>优先级的无界阻塞队列</strong></li>
</ul>
</li>
<li><p><strong>threadFactory: 线程工厂</strong>，用于<strong>创建新线程</strong>，threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n(m为线程池的编号，n为线程池内的线程编号)。</p>
</li>
<li><p><strong>handler: 线程饱和策略</strong>，当任务太多来不及处理时，用于拒绝任务，实现了RejectedExecutionHandler接口</p>
<ul>
<li><strong>AbortPolicy</strong>: 直接抛出异常，阻止系统正常运行</li>
<li><strong>CallerRunsPolicy</strong>: 直接在调用者线程中，运行当前被丢弃的任务</li>
<li><strong>DiscardOlderPolicy</strong>: 丢弃最老的一个请求，并执行当前任务</li>
<li><strong>DiscardPolicy</strong>: 丢弃无法处理的任务，不予任何处理</li>
</ul>
</li>
</ul>
<hr>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/6024478-88ee7b20f8f45825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/937/format/webp" alt="avator"></p>
<ul>
<li>首先判断<strong>基本线程池</strong>是否已满，未满则创建一个工作线程执行任务，满了则下一步</li>
<li>线程池判断<strong>工作队列</strong>是否已满，未满则将新提交的任务存储到工作队列中，满了则下一步</li>
<li>线程池判断<strong>整个线程池</strong>是否已满，未满则创建新的工作线程执行任务，满了则交给饱和策略处理</li>
</ul>
<hr>
<h3 id="线程池提交"><a href="#线程池提交" class="headerlink" title="线程池提交"></a>线程池提交</h3><ul>
<li>使用execute提交，没有返回值</li>
<li>使用submit提交，会<strong>返回一个future</strong>，通过future.get()获取，<strong>阻塞直到任务执行完</strong>，而get(long timeout,TimeUnit,unit)方法则<strong>会阻塞一段时间后</strong>立即返回<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Object s = future.get();</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">    <span class="comment">//处理中断异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">    <span class="comment">//处理无法执行任务异常</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    executo.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><ul>
<li>调用线程<strong>shutdown或shutdownNow</strong>方法，遍历线程池中的的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止</li>
<li>区别在于: <strong>shutdownNow将线程池的状态设为STOP</strong>，然后<strong>尝试停止所有的正在执行或暂定任务的线程，并返回等待执行任务的列表</strong>; 而<strong>shutdown是将线程池的状态设为SHUTDOWN状态</strong>，然后中断所有没有正在执行任务的线程</li>
<li>只要调用了两个方法中的任意一个，<strong>isShutdown方法就会返回true</strong>，而所有的任务都已关闭即所有的线程池关闭，<strong>isTerminated才会返回true</strong></li>
</ul>
<hr>
<h3 id="线程池的配置"><a href="#线程池的配置" class="headerlink" title="线程池的配置"></a>线程池的配置</h3><ul>
<li>任务性质<ul>
<li>CPU密集型任务: 尽量使用较小的线程池，核心数+1，若开过多的线程池，会造成CPU过度切换</li>
<li>IO密集型任务: 使用稍大的线程池，核心数*2，IO密集型CPU使用率不高，因此CPU在等待IO时有其它线程处理其它任务</li>
<li>混合型任务: 可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理</li>
</ul>
</li>
<li>任务优先级: 高，中，低</li>
<li>任务执行时间: 长，中，短</li>
<li>任务依赖性: 是否依赖其他系统资源，如数据库连接</li>
</ul>
<hr>
<h3 id="Java提供的线程池"><a href="#Java提供的线程池" class="headerlink" title="Java提供的线程池"></a>Java提供的线程池</h3><ul>
<li><strong>newCachedThreadPool</strong>：用来创建一个<strong>可以无限扩大</strong>的线程池，适用于<strong>负载较轻</strong>的场景，执行短期异步任务。(可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换)</li>
<li><strong>newFixedThreadPool</strong>：创建一个<strong>固定大小</strong>的线程池，因为采用<strong>无界的阻塞队列</strong>，所以实际线程数量永远不会变化，适用于<strong>负载较重</strong>的场景，对当前线程数量进行限制。(保证线程数可控，不会造成线程过多，导致系统负载更为严重)</li>
<li><strong>newSingleThreadExecutor</strong>：创建一个<strong>单线程</strong>的线程池，适用于需要保证顺序执行各个任务</li>
<li><strong>newScheduledThreadPool</strong>：适用于<strong>执行延时或者周期性任务</strong></li>
</ul>
<hr>
<h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><ul>
<li><strong>taskCount</strong>: 线程池需要执行的任务数量</li>
<li><strong>completedTaskCount</strong>: 已完成的任务数量，小于等于taskCount</li>
<li><strong>largestPoolSize</strong>: 曾经创建过的最大线程数量，可以判断线程池是否满过</li>
<li><strong>getPoolSize</strong>: 线程池线程数量，若线程池不销毁的话，线程不会自动销毁</li>
<li><strong>getActiveCount</strong>: 获取活动的线程数 </li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lihc-hhh.github.io/2021/04/04/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LHC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">Java-类加载</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-04 16:46:49 / 修改时间：16:49:36" itemprop="dateCreated datePublished" datetime="2021-04-04T16:46:49+08:00">2021-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-类加载过程"><a href="#Java-类加载过程" class="headerlink" title="Java-类加载过程"></a>Java-类加载过程</h1><ul>
<li>Java虚拟机类加载全过程包括 加载，验证，准备，解析和初始化<br><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3278574594,735796484&fm=26&gp=0.jpg" alt="avator"><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3></li>
<li>加载是整个类加载过程中的一个阶段，完成的事情:<ul>
<li>通过一个类的全限定名来获取此类的二进制字节流<ul>
<li>注意这里不一定非要从一个Class文件中获取，也可以从ZIP包中，运行时计算中得到</li>
</ul>
</li>
<li>将这个字节流代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
</li>
<li>加载阶段既可以使用Java虚拟机<strong>内置的引导类加载器</strong>来完成，也可以由用户<strong>自定义的类加载器</strong>完成</li>
<li>数组本身不通过类加载器创建，而是由Java虚拟机直接在内存中动态构造出来的</li>
</ul>
<hr>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><ul>
<li><p>为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，不危害虚拟机安全</p>
</li>
<li><p><strong>文件格式验证</strong>: 验证字节流是否符合Class文件格式规范</p>
<ul>
<li>主次版本号是否在JVM接收范围</li>
<li>常量池的常量中是否有不被支持的常量类型</li>
</ul>
</li>
<li><p><strong>元数据验证</strong>: 对字节码描述的信息进行语义分析</p>
<ul>
<li>这个类是否有父类</li>
<li>父类是否继承了不该继承的类(比如被final修饰的类)</li>
</ul>
</li>
<li><p><strong>字节码验证</strong>: 验证阶段最复杂的阶段，通过数据流和控制流分析，确定程序语义是合法，符合逻辑的</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令</li>
</ul>
</li>
<li><p><strong>符号引用验证</strong>: 发生在虚拟机将符号引用转为直接引用的时候</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><ul>
<li>是正式为类中定义的变量(即静态变量)分配内存并设置初始值，应当在方法区分配；JDK7之前HotSpot使用永久代实现方法区，内存分配在方法区，JDK8及之后，类变量会随着Class对象一起放在Java堆  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">8000</span>;</span><br><span class="line">实际上value在准备阶段的初始值为<span class="number">0</span>而不是<span class="number">8000</span>，将value赋值为<span class="number">8000</span>是在程序被编译后，存放在构造器&lt;clinit&gt;()方法中</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">在编译阶段会为value生成ConstantValue属性，在准备阶段会赋值为<span class="number">10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><ul>
<li>解析阶段是Java虚拟机将常量池内的符号引用转化为直接引用的过程</li>
<li>符号引用就是class文件中的CONSTANT_Class_info、 CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量</li>
<li>符号引用: 一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</li>
<li>直接引用: 是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄；如果有直接引用，那引用的目标必定存在；<strong>直接引用是和虚拟机实现的内存布局直接相关的</strong>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同</li>
</ul>
<hr>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><ul>
<li><p>初始化阶段是类加载的最后一个阶段，除了在加载阶段可以自定义类加载器以外，其它操作都是JVM主导。到了初始化阶段，才开始<strong>真正执行类中定义的java代码</strong></p>
</li>
<li><p>初始化阶段就是<strong>执行类构造器<clinit>()方法的过程</strong></p>
</li>
<li><p>&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的</p>
</li>
<li><p>如果一个类中没有对静态变量赋值也没有静态语句块，编译时可不用生成<clinit>()方法</p>
</li>
<li><p><strong>以下情况不会进行初始化</strong></p>
<ul>
<li>通过子类用用父类的静态字段，只会出发父类的初始化，不会出发子类的初始化</li>
<li>定义对象数组不会出发该类的初始化</li>
<li>通过类名获取Class对象，不会触发初始化</li>
<li>通过ClassLoader默认的LoadClass方法也不会出发初始化</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lihc-hhh.github.io/2021/04/04/Java-%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LHC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/Java-%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">Java-反射</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-04 16:46:41 / 修改时间：16:49:23" itemprop="dateCreated datePublished" datetime="2021-04-04T16:46:41+08:00">2021-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java-反射"></a>Java-反射</h1><!-- TOC -->

<ul>
<li><a href="#java-%E5%8F%8D%E5%B0%84">Java-反射</a><pre><code>      - [1. 概念](#1-概念)
      - [2. 反射作用](#2-反射作用)
      - [3. 反射机制中的类](#3-反射机制中的类)
      - [4. 具体实现](#4-具体实现)
      - [5. 好处](#5-好处)
</code></pre>
</li>
</ul>
<!-- /TOC -->
<h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ol>
<li><p>主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。反射是java中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以再运行时装配，无需在组件之间进行源代码链接<br>&nbsp;</p>
</li>
<li><p>在程序运行期间，系统始终为所有对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时的类型信息选择相应的方法执行。保存这些信息的类成为 <strong>Class</strong>。<br>&nbsp;</p>
</li>
<li><p>java代码运行的阶段</p>
<ol>
<li>source源代码阶段: .java -&gt; .class字节码文件</li>
<li>Class类对象阶段: .class字节码文件被类加载器加载进内存，并将其封装成class对象(用于在内存中描述字节码文件)，class对象将原字节码文件中的成员变量抽取等装成数组Field[]，将原字节码文件的构造函数封装成数组Construction[],将成员变量封装成Method[]。当然Class类不止这三个，还封装了很多，常用的是以上这三个。</li>
<li>RunTime运行阶段，创建对象的过程new<br><img src="http://note.youdao.com/yws/public/resource/128508bf6a04968eced81ede9ac1b304/xmlnote/1DE7C44C1DFF4E92AA54BDB012FB446A/10629" alt="avator"></li>
</ol>
</li>
<li><p>加载的时候: Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p>
</li>
<li><p>如图是类的正常加载过程：反射的原理在于class对象。<br><img src="https://img-blog.csdn.net/20170513133210763" alt="avator"></p>
<h4 id="2-反射作用"><a href="#2-反射作用" class="headerlink" title="2. 反射作用"></a>2. 反射作用</h4><ul>
<li>反编译 .class -&gt; .java</li>
<li>通过反射机制访问Java对象的属性，方法，构造方法等</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象，这个对象很像C++的函数指针<h4 id="3-反射机制中的类"><a href="#3-反射机制中的类" class="headerlink" title="3. 反射机制中的类"></a>3. 反射机制中的类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Class;                </span><br><span class="line">java.lang.reflect.Constructor; java.lang.reflect.Field;        </span><br><span class="line">java.lang.reflect.Method;</span><br><span class="line">java.lang.reflect.Modifier;</span><br></pre></td></tr></table></figure>
<h4 id="4-具体实现"><a href="#4-具体实现" class="headerlink" title="4. 具体实现"></a>4. 具体实现</h4></li>
</ul>
</li>
<li><p>反射机制获取类有三种方法，我们来获取Employee类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式： 源代码阶段 </span></span><br><span class="line">Classc1 = Class.forName(<span class="string">&quot;Employee&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式： class类对象阶段</span></span><br><span class="line"><span class="comment">//java中每个类型都有class 属性.</span></span><br><span class="line">Classc2 = Employee.class;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第三种方式：RunTime运行阶段</span></span><br><span class="line"><span class="comment">//java语言中任何一个java对象都有getClass 方法</span></span><br><span class="line">Employeee = <span class="keyword">new</span> Employee();</span><br><span class="line">Classc3 = e.getClass(); <span class="comment">//c3是运行时类 (e的运行时类是Employee)</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建对象：获取类以后我们来创建它的对象，利用newInstance</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c =Class.forName(<span class="string">&quot;Employee&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建此Class 对象所表示的类的一个新实例</span></span><br><span class="line">Objecto = c.newInstance(); <span class="comment">//调用了Employee的无参数构造方法.</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取属性: 分 所有属性和特定属性</p>
<p> 获取所有属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取整个类</span></span><br><span class="line">Class c = Class.forName(<span class="string">&quot;java.lang.Integer&quot;</span>);</span><br><span class="line"><span class="comment">//获取所有的属性?</span></span><br><span class="line">Field[] fs = c.getDeclaredFields();</span><br><span class="line"><span class="comment">//定义可变长的字符串，用来存储属性</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">//通过追加的方法，将每个属性拼接到此字符串中</span></span><br><span class="line"><span class="comment">//最外边的public定义</span></span><br><span class="line">sb.append(Modifier.toString(c.getModifiers()) + <span class="string">&quot; class &quot;</span> + c.getSimpleName() +<span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line"><span class="comment">//里边的每一个属性</span></span><br><span class="line"><span class="keyword">for</span>(Field field:fs)&#123;</span><br><span class="line">	sb.append(<span class="string">&quot;\t&quot;</span>);<span class="comment">//空格</span></span><br><span class="line">	sb.append(Modifier.toString(field.getModifiers())+<span class="string">&quot; &quot;</span>);<span class="comment">//获得属性的修饰符，例如public，static等等</span></span><br><span class="line">	sb.append(field.getType().getSimpleName() + <span class="string">&quot; &quot;</span>);<span class="comment">//属性的类型的名字</span></span><br><span class="line">	sb.append(field.getName()+<span class="string">&quot;;\n&quot;</span>);<span class="comment">//属性的名字+回车</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">sb.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">System.out.println(sb);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>获取特定方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">			</span><br><span class="line">	<span class="comment">//以前的方式：</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	User u = new User();</span></span><br><span class="line"><span class="comment">	u.age = 12; //set</span></span><br><span class="line"><span class="comment">	System.out.println(u.age); //get</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">			</span><br><span class="line">	<span class="comment">//获取类</span></span><br><span class="line">	Class c = Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">	<span class="comment">//获取id属性</span></span><br><span class="line">	Field idF = c.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">	<span class="comment">//实例化这个类赋给o</span></span><br><span class="line">	Object o = c.newInstance();</span><br><span class="line">	<span class="comment">//打破封装</span></span><br><span class="line">	idF.setAccessible(<span class="keyword">true</span>); <span class="comment">//使用反射机制可以打破封装性，导致了java对象的属性不安全。</span></span><br><span class="line">	<span class="comment">//给o对象的id属性赋值&quot;110&quot;</span></span><br><span class="line">	idF.set(o, <span class="string">&quot;110&quot;</span>); <span class="comment">//set</span></span><br><span class="line">	<span class="comment">//get</span></span><br><span class="line">	System.out.println(idF.get(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-好处"><a href="#5-好处" class="headerlink" title="5. 好处"></a>5. 好处</h4><ol>
<li>对于封装好的框架来说，直接拿来用就可以，不用修改框架内的代码。但如果我们使用的是传统的new形式来实例化，那么当类名更改的时候，我们就要修改java代码，还有重新测试，编译等。如果仅修改配置文件就简单的多。</li>
<li>反射还能<strong>解耦</strong>，假设我们使用的是new这种形式进行对象的实例化，此时如果在项目的某一个小模块中我们的一个实例类丢失了，那么在编译期间就会报错，以导致整个项目无法启动。而对于反射创建对象Class.forName(“全类名”);这种形式，我们在编译期需要的仅仅只是一个字符串（全类名），在编译期不会报错，这样其他的模块就可以正常的运行，而不会因为一个模块的问题导致整个项目崩溃。这就是Spring框架中IOC控制反转的本质。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lihc-hhh.github.io/2021/04/04/final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LHC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">final,finally,finalize的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-04 16:46:29 / 修改时间：16:49:06" itemprop="dateCreated datePublished" datetime="2021-04-04T16:46:29+08:00">2021-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final,finally,finalize的区别"></a>final,finally,finalize的区别</h1><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li>既是修饰符，又是关键字</li>
<li>被final修饰的类<strong>无法被继承</strong></li>
<li>被final修饰的基本数据类型的变量，初始化之后便<strong>不能修改</strong></li>
<li>被final修饰的引用变量，初始化之后<strong>不能再指向其他对象</strong>，但指向对象的<strong>内容是可变的</strong></li>
<li>被final修饰的<strong>class对象、集合对象，之后不能被重新new，但是可以改变其中属性或集合的值</strong></li>
<li>被final修饰的方法将<strong>无法被重写</strong>，但<strong>允许重载</strong>，如类的private方法就隐式的声明为final方法</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201029221507497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6eGJfY29kZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="avator"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		System.out.println(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;  <span class="comment">//不能被重写</span></span><br><span class="line">		System.out.println(id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> count)</span> </span>&#123; <span class="comment">//可以被重载</span></span><br><span class="line">		System.out.println(id+count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><ul>
<li>是关键字</li>
<li>finally异常处理时提供finally块<strong>执行清除操作</strong>，不管有没有异常抛出，finally块都会被执行，用于释放资源</li>
<li>finally块正常情况一定会执行，除了一下两个情况:<ul>
<li>对应的try块没有执行，那么try块对应的finally块也不会执行</li>
<li>若在try块中JVM关机，如system.exit(n),则finally块也不会执行</li>
</ul>
</li>
<li>finally块如果有return语句，则会<strong>覆盖try或catch中的return语句，导致二者无法return，所以强烈建议finally块不要存在return关键字</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    code;</span><br><span class="line">    more code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionType e) &#123;</span><br><span class="line">    handler <span class="keyword">for</span> <span class="keyword">this</span> type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionType d)&#123;</span><br><span class="line">    handler <span class="keyword">for</span> <span class="keyword">this</span> type;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><ul>
<li>finalize()是Object类的protected方法，<strong>子类可以覆盖此方法以实现资源清理</strong></li>
<li>GC在回收对象时会调用此方法</li>
<li>当然finalize存在一些不足:<ul>
<li>java语言规范不保证finalize方法被及时执行，也不保证一定会执行</li>
<li>finalize<strong>最多由GC执行一次</strong></li>
<li>finalize()方法中，可将待回收的对象赋值给GC Roots可达的对象引用，以<strong>达到对象再生的目的</strong></li>
<li>finalize()方法可能带来性能问题，因为JVM通常在单独的低优先级线程中执行finalize</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		System.out.println(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.finalize();</span><br><span class="line">		System.out.println(<span class="string">&quot;finalize 被调用&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lihc-hhh.github.io/2021/04/04/equals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LHC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/equals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">equals和==的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-04 16:46:11 / 修改时间：16:48:44" itemprop="dateCreated datePublished" datetime="2021-04-04T16:46:11+08:00">2021-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="equals-和-的区别"><a href="#equals-和-的区别" class="headerlink" title="equals 和 == 的区别"></a>equals 和 == 的区别</h1><!-- TOC -->

<ul>
<li><a href="#equals-%E5%92%8C--%E7%9A%84%E5%8C%BA%E5%88%AB">equals 和 == 的区别</a><pre><code>- [1. == 的作用](#1--的作用)
- [2. equals作用](#2-equals作用)
- [3. equals的重写](#3-equals的重写)
- [4. 例子](#4-例子)
- [5. java中的堆和栈](#5-java中的堆和栈)
</code></pre>
</li>
</ul>
<!-- /TOC -->
<h4 id="1-的作用"><a href="#1-的作用" class="headerlink" title="1. == 的作用"></a>1. == 的作用</h4><ol>
<li>== 的作用: 对内容或值进行比较(用于基本类型或者引用类型之间的比较)</li>
<li>基本类型比较值是否相同; 引用类型比较指向的地址是否相同(java中唯一使用真实地址的操作)</li>
<li>格式: A == B</li>
</ol>
<h4 id="2-equals作用"><a href="#2-equals作用" class="headerlink" title="2. equals作用"></a>2. equals作用</h4><ol>
<li>作用: 对象比较(先比较两个对象的类型，再对对象中属性值比较)</li>
<li>在实际使用中，一般会重写定义的class的equals方法</li>
<li>特点<ul>
<li>只能用于引用类型</li>
<li>容易产生<strong>空指针异常</strong></li>
<li>equals相同，hashCode一定相同</li>
<li>hashCode相同，equals不一定相同<br>例如: a存储了一个对象的地址，b == null，a和b分别对equals进行调用<br>a.equals(b) = false<br>b.equals(a) 空指针异常</li>
</ul>
</li>
</ol>
<h4 id="3-equals的重写"><a href="#3-equals的重写" class="headerlink" title="3. equals的重写"></a>3. equals的重写</h4><ol>
<li>在Object类中定义了equals方法；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这种比较对象内存地址值意义不大，所以在一些实际的类库中，这个方法被重写了，如String，Data类。</li>
<li>比如 String 中重写的equals方法:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == anObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span>(n == anotherString.value.length)&#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n-- != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v1[i] != v2[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-例子"><a href="#4-例子" class="headerlink" title="4. 例子"></a>4. 例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1==str2); <span class="comment">//true 可以看出str1和str2指向同一个对象</span></span><br><span class="line"></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(str1==str2); <span class="comment">//false 用new是生成不同的对象，new一次，生成一个</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-java中的堆和栈"><a href="#5-java中的堆和栈" class="headerlink" title="5. java中的堆和栈"></a>5. java中的堆和栈</h4></li>
<li>堆和栈都是java用来在RAM中存放数据的地方，java自动管理栈和堆，程序员不能直接设置</li>
<li>java的堆是一个运行时的数据区，类的对象从中分配空间。这些对象通过new，newarray等建立。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">编译器先处理<span class="keyword">int</span> a = <span class="number">3</span>; 首先在栈中创建一个变量为的引用，然后查找栈中是否有 <span class="number">3</span> 这个值，如果没找到，就将<span class="number">3</span>存进了，把a指向<span class="number">3</span>；</span><br><span class="line">接着处理<span class="keyword">int</span> b = <span class="number">3</span>; 因为栈中已经有<span class="number">3</span>了，所以直接把b指向<span class="number">3</span>。</span><br><span class="line">这时如果有 <span class="keyword">int</span> a = <span class="number">4</span>, 那么编译器就会重新搜索栈，如果没有<span class="number">4</span>，就把<span class="number">4</span>存进了，把a指向<span class="number">4</span>,因此a的值不影响b的值</span><br><span class="line"></span><br><span class="line">对于String</span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1==str2); <span class="comment">//true 可以看出str1和str2指向同一个对象</span></span><br><span class="line"></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(str1==str2);  <span class="comment">//false</span></span><br><span class="line">同理，String str1 = <span class="string">&quot;abc&quot;</span>; String str2 = <span class="string">&quot;abc&quot;</span>; 在内存中只存在一个对象而已，有利于节省内存空间，在一定程度上提高运行速度，因为JVM会自动根据栈中的实际情况来决定是否有必要创建新对象。</span><br><span class="line">而 String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); 是在堆中创建对象，不管字符串是否相等，加重程序负担</span><br><span class="line">由于 String类的immutable性质，当String变量需要经常更换值时，应该考虑使用StringBuffer类，以提高效率</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lihc-hhh.github.io/2021/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LHC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">操作系统-线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-04 16:45:52 / 修改时间：16:48:04" itemprop="dateCreated datePublished" datetime="2021-04-04T16:45:52+08:00">2021-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="操作系统-线程"><a href="#操作系统-线程" class="headerlink" title="操作系统-线程"></a>操作系统-线程</h1><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>引入进程是为了多道程序并发执行，引入线程则为了减小程序并发执行的开销，提高并发性能</li>
<li>线程又称为<strong>轻量级进程</strong>，是基本的CPU执行单元，也是程序执行流的最小单元; 是进程中的一个实体，是被系统独立调度和分配的基本单位</li>
<li>线程由**线程ID，程序计数器，寄存器集合和堆栈组成</li>
<li>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程可以并发执行</li>
<li>线程也有<strong>就绪，阻塞，运行</strong>态</li>
</ul>
<hr>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>线程是轻型实体，不拥有系统资源，但每个线程具有<strong>唯一的标识符和线程控制块</strong>; 线程控制块记录<strong>线程执行的寄存器和栈等线程状态</strong></li>
<li>不同的线程可以执行相同的程序; 即同一个服务程序被不同用户调用时，操作系统把它们创建成不同的线程</li>
<li>线程不拥有系统资源，只拥有运行必不可少的一点资源; 与同属一个进程的其他线程共享进程中的资源</li>
<li>单CPU系统中，各线程交替占用CPU; 多CPU系统中，各线程占用不同的CPU，若各个CPU同时为一个进程中各个线程服务，可缩短处理时间</li>
</ul>
<hr>
<h4 id="与进程比较"><a href="#与进程比较" class="headerlink" title="与进程比较"></a>与进程比较</h4><ul>
<li>引入线程之后，<strong>线程是独立调度的基本单位，进程是拥有资源的基本单位</strong></li>
<li>线程不拥有资源，但线程可以访问其隶属进程的系统资源</li>
<li>引入线程的操作系统，不仅进程可以并发执行，线程也可以，使得操作系统有更好的并发性</li>
<li>创建和撤销进程时，系统为之分配或回收资源等付出的开销远大于创建和撤销线程; 进程切换涉及执行进程CPU环境的保存和新调度到进程CPU环境的设置，而线程切换只需要保存和设置少量寄存器的内容，开销很小</li>
<li>进程间通信(IPC)需要经常同步和互斥手段辅助，以保证数据一致性，而线程间可以直接读写进程数据段进行通信</li>
</ul>
<hr>
<h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><ul>
<li>用户级线程(User-Level Thread ULT)<ul>
<li>线程管理的所有工作都由<strong>应用程序</strong>完成，内核意识不到线程存在</li>
<li>应用程序可以通过使用线程库设计成多线程程序</li>
</ul>
</li>
<li>内核级线程(Kernel-Level Thread KLT)<ul>
<li>线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码</li>
<li>内核为进程及其内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201028142429652.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6eGJfY29kZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="avator"></p>
<hr>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><ul>
<li>多对一模型<ul>
<li>多个用户级线程映射到一个内核级线程<ul>
<li>优点: 线程管理在用户空间完成，因此效率比较高</li>
<li>缺点: 若一个线程在使用内核服务时被阻塞，整个进程都会被阻塞; 多个线程不能并行运行在处理器上</li>
</ul>
</li>
</ul>
</li>
<li>一对一模型<ul>
<li>一个用户级线程映射到一个内核级线程<ul>
<li>优点: 运行并发执行，一个线程阻塞，运行另一个进程执行</li>
<li>缺点: 每创建一个用户级线程都要创建一个内核级线程，开销大，影响性能</li>
</ul>
</li>
</ul>
</li>
<li>多对多模型<ul>
<li>n个用户级线程映射到m个内核级线程  m&lt;=n<ul>
<li>是上两个模型的折中，既克服了多对一模型的并发度不高，又克服了一对一模型开销大的缺点，还拥有各自的优点</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lihc-hhh.github.io/2021/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LHC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">操作系统-进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-04 16:45:41 / 修改时间：16:47:46" itemprop="dateCreated datePublished" datetime="2021-04-04T16:45:41+08:00">2021-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="操作系统-进程"><a href="#操作系统-进程" class="headerlink" title="操作系统-进程"></a>操作系统-进程</h1><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>在多道程序的环境下，允许多个程序并发执行，此时他们将失去封闭性，并具有间断性及不可再现性的特征；为了<strong>更好地描述和控制程序的并发执行，实现并发性和共享性</strong>，引入<strong>进程</strong></li>
<li>为了使参与并发执行的程序能独立的运行，为进程配备了<strong>进程控制块–PCB(Process Control Block)<strong>；利用PCB描述进程基本情况和运行状态进而控制和管理进程；</strong>PCB是进程存在的唯一标志</strong>   </li>
<li>程序段，相关数据段和PCB构成<strong>进程映像(进程实体)</strong></li>
<li>所以创建进程实际上就是创建进程映像中的PCB；撤销进程就是撤销进程的PCB</li>
<li>进程的定义<ul>
<li>程序的一次执行过程</li>
<li>一个程序及其数据在处理机上顺序执行时发生的活动</li>
<li><strong>进程是具有独立功能的程序在一个数据集合上运行的过程；是系统进行资源分配和调度的独立单位</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ol>
<li><strong>动态性</strong>: 进程是动态产生和消亡的，有着<strong>创建，活动，暂定，终止</strong>等过程，具有一定生命周期</li>
<li><strong>并发性</strong>: <strong>多个进程实体同时存在于内存中</strong>，能在一段时间内同时运行; 引入进程的目的就是使程序能够与其他程序并发执行，提高资源利用率</li>
<li><strong>独立性</strong>: 进程实体是一个能<strong>独立运行，独立获得资源和接收调度</strong>的基本单位</li>
<li><strong>异步性</strong>: 进程<strong>按各自独立的，不可预知的速度</strong>向前推进; 异步会导致执行结果的不可再现性，所以必须配置相应的进程同步机制</li>
<li><strong>结构性</strong>: 每个进程都配置一个PCB对其进行描述</li>
</ol>
<hr>
<h4 id="状态与转换"><a href="#状态与转换" class="headerlink" title="状态与转换"></a>状态与转换</h4><ol>
<li><strong>创建态</strong>: 进程正在被创建，尚未转到就绪态，<strong>创建过程</strong>: 申请一个空白PCB，向PCB写入一些控制和管理进程的信息，然后由系统为该进程分配运行时资源，最后转为就绪态</li>
<li><strong>就绪态</strong>: 进程获得了除处理器的一切资源，一旦得到处理器，就开始运行; 系统中处于就绪态的进程可能有多个，组成<strong>就绪队列</strong></li>
<li><strong>运行态</strong>: 进程正在处理器上运行</li>
<li><strong>阻塞态</strong>: 又称<strong>等待态</strong>。进程正在<strong>等待某一资源而暂停运行</strong>，比如等待IO处理; 即使处理器空闲也不能运行</li>
<li><strong>结束态</strong>: 进程正在从系统中消失，可能是<strong>正常结束或其他原因中断退出</strong>; 进程需要结束时，首先置该进程为结束态，然后再进一步处理资源回收与回收等工作</li>
</ol>
<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1850514320,2017727660&fm=26&gp=0.jpg" alt="avator"></p>
<ul>
<li><strong>就绪态-&gt;运行态</strong>: 就绪态的进程被调度后**获得处理器资源(分派处理器时间片)**，进程转为运行态</li>
<li><strong>运行态-&gt;就绪态</strong>: 运行态的<strong>进程的时间片用完</strong>，不得不让出处理器，进程转为就绪态</li>
<li><strong>运行态-&gt;阻塞态</strong>: 进程请求的某一资源的使用和分配发生时，进程转为阻塞态; 进程以系统调用的形式请求操作系统提供服务，这是一种<strong>特殊的，由运行用户态程序调用操作系统内核过程的形式</strong></li>
<li><strong>阻塞态-&gt;就绪态</strong>: 进程<strong>等待的事件或者资源到来</strong>时，中断处理程序把相应阻塞态进程转为就绪态</li>
</ul>
<hr>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><ul>
<li>允许一个进程创建一个另一个进程，成为<strong>父子进程</strong>，子进程可以继承父进程拥有资源，子进程撤销时，从父进程获得的资源归还给父进程，父进程撤销时，也撤销其所有的子进程</li>
<li>创建新进程:<ul>
<li>为新进程分配<strong>唯一的进程标识号</strong>，并申请一个空白PCB(PCB有限)，若PCB申请失败，则创建失败</li>
<li>为进程分配资源，为进程的程序和数据分配必要的内存空间(在PCB中体现)，若内存空间不足，处于阻塞态，等待内存资源</li>
<li>初始化PCB，包括初始化标志信息，处理器状态信息，控制信息以及进程优先级</li>
<li>若就绪队列未满，则插入就绪队列，等待被调度执行</li>
</ul>
</li>
</ul>
<hr>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ul>
<li>进程切换指处理器从一个进程的运行转到另一个进程上运行:<ul>
<li>保存处理器上下文，包括<strong>程序计数器和其他寄存器</strong></li>
<li>更新PCB消息</li>
<li>把进程的PCB移入相应队列，如就绪，阻塞等队列</li>
<li>选择另一个进程运行，并更新其PCB</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理器上下文 </li>
</ul>
</li>
</ul>
<hr>
<h4 id="进程阻塞与唤醒"><a href="#进程阻塞与唤醒" class="headerlink" title="进程阻塞与唤醒"></a>进程阻塞与唤醒</h4><ul>
<li>阻塞原语:<ul>
<li>找到要被阻塞进程的标识号对应的PCB</li>
<li>若为运行态，保护现场，转为就绪态，停止运行</li>
<li>将该PCB插入响应事件的等待队列，将处理器资源调度给其他就绪进程</li>
</ul>
</li>
<li>唤醒原语:<ul>
<li>在该事件的等待队列找到相应进程的PCB</li>
<li>将其从等待队列移出，置为就绪态</li>
<li>将该PCB插入就绪队列，等待调度</li>
</ul>
</li>
</ul>
<hr>
<h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><ul>
<li>正常结束: 进程的任务已完成，准备退出运行</li>
<li>异常结束: 运行时，发生了异常事件使得无法继续运行，如<strong>存储区越界，非法指令，运行超时，算术运算错</strong>等</li>
<li>外界干预: 应外界的请求而终止运行，如<strong>操作员或操作系统干预，父进程请求或父进程终止</strong> </li>
<li>终止过程(撤销原语):<ul>
<li>根据被终止状态的标识符，检索PCB，读出该进程状态</li>
<li>若被终止状态处于执行状态，则立即终止，将处理器资源分配给其他进程</li>
<li>若有子孙进程，则将其所有子孙进程终止</li>
<li>将该进程的资源或归还给其父进程或操作系统</li>
<li>将该PCB从所在队列删除</li>
</ul>
</li>
</ul>
<hr>
<h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h4><ul>
<li>进程创建时，操作系统会为其创建一个PCB，该结构常驻内存，任意时刻都可存取，进程结束时删除；PCB是进程存在唯一标志，是进程实体的一部分<ul>
<li><strong>进程描述信息</strong>: <ul>
<li>进程标识符 – 标识各个进程</li>
<li>用户标识符 – 进程归属的用户,为共享和保护服务</li>
</ul>
</li>
<li><strong>进程控制和管理信息</strong>: <ul>
<li>进程当前状态 – 描述进程状态信息，作为处理器调度依据</li>
<li>进程优先级 – 优先级高的可以优先获得处理器</li>
</ul>
</li>
<li><strong>资源分配清单</strong>: 用于说明有关内存地址空间和虚拟地址空间的状况，所打开文件列表和所使用的的输入输出设备信息</li>
<li><strong>处理器相关信息</strong>: 处理器中各寄存器的值，进程被切换时，处理器状态信息被保存在相应的PCB中，以便该进程重新执行时能从断点执行</li>
</ul>
</li>
<li>为了方便和管理，组织PCB有两种方式<ul>
<li>链接方式: 将统一状态的PCB链接成一个队列，不同状态不同队列，阻塞态的进程可根据阻塞原因分为多个队列</li>
<li>索引方式: 将同一状态的进程组织为一个<strong>索引表</strong>，表项指向相应PCB，不同状态对应不同索引表</li>
</ul>
</li>
</ul>
<hr>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ul>
<li><p>共享存储</p>
<ul>
<li>通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行读写完成进程之间信息交换</li>
<li>低级的共享是基于<strong>数据结构</strong>的共享; 高级共享是基于<strong>存储区</strong>的共享</li>
<li>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，数据交互由用户自己安排<br><img src="https://img-blog.csdnimg.cn/20181204153005346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5bl8wMA==,size_16,color_FFFFFF,t_70" alt="avator"> </li>
</ul>
</li>
<li><p>消息传递</p>
<ul>
<li>直接通信: 发送进程把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从缓冲队列取消息</li>
<li>间接通信: 发送进程把消息发送到中间实体，接收进程从实体取得消息，中间实体一般称为<strong>信箱</strong>，又称<strong>信箱通信方式</strong>，比如电子邮件系统 </li>
</ul>
</li>
<li><p>管道通信</p>
<ul>
<li>管道: 用于连接一个读写进程以实现进程通信的一个共享文件，又名<strong>pipe文件</strong>；以字符流形式写入</li>
<li>有固定的读出和写入端，不能更改;</li>
<li>只能用于父子进程或者兄弟进程之间通信</li>
<li>管道是<strong>固定大小</strong>的缓冲区，Linux中是4KB大小</li>
<li>管道读取是一次性动作，数据一旦被读取就要从管道内丢弃，以释放空间写入更多数据<br><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2002070929,3864139503&fm=26&gp=0.jpg" alt="avator"></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lihc-hhh.github.io/2021/04/04/%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LHC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/" class="post-title-link" itemprop="url">静态动态绑定</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-04 16:45:29 / 修改时间：16:48:22" itemprop="dateCreated datePublished" datetime="2021-04-04T16:45:29+08:00">2021-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-–-静态绑定和动态绑定"><a href="#Java-–-静态绑定和动态绑定" class="headerlink" title="Java – 静态绑定和动态绑定"></a>Java – 静态绑定和动态绑定</h1><!-- TOC -->

<ul>
<li><a href="#java----%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A">Java – 静态绑定和动态绑定</a><pre><code>- [1. 概念](#1-概念)
- [2. 静态绑定](#2-静态绑定)
- [3. 动态绑定](#3-动态绑定)
- [4. 小结](#4-小结)
</code></pre>
</li>
</ul>
<!-- /TOC -->
<h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>绑定</strong>: 把一个方法与其所在的类/对象 关联起来叫做方法的绑定。分为静态绑定(前期绑定)和动态绑定(后期绑定)</p>
<h4 id="2-静态绑定"><a href="#2-静态绑定" class="headerlink" title="2. 静态绑定"></a>2. 静态绑定</h4><p><strong>静态绑定</strong>: 在程序运行前就已经知道方法属于哪个类，在编译时就可以连接到类中，定位到这个方法<br>在Java中，==final，private，static==修饰的方法以及构造函数都是静态绑定，不需要程序运行，不需具体的实例对象就可以知道这个方法的具体内容<br>Private: 私有，被private修饰的方法是无法由本类之外的其他类所调用的，也就是本类特有，所以就由编译器识别方法属于哪个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String talk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">canTalk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> talk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// private 修饰的方法是Person类独有的，所以Animal类无法访问(动物本来就不能说话)</span></span><br><span class="line"><span class="comment">//        p.canTalk();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>final: final修饰的方法不能重写，但可以由子类调用，生命为final可以关闭动态绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String fruitName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> String <span class="title">eatingFruit</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eating&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> fruitName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"><span class="comment">//  不能重写final方法，eatingFruit只属于Fruit类，Apple类无法调用</span></span><br><span class="line"><span class="comment">//    final String eatingFruit(String name)&#123;</span></span><br><span class="line"><span class="comment">//        super.eatingFruit(name);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="function">String <span class="title">eatingApple</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.eatingFruit(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>static: static修饰的方法只能通过<strong>类名.变量名</strong>直接调用，这样的话类名就是确定的，并不会产生多态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;由 superclass 说你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;由 SubClass 说你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SuperClass.sayHello();</span><br><span class="line">        SubClasss.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h4 id="3-动态绑定"><a href="#3-动态绑定" class="headerlink" title="3. 动态绑定"></a>3. 动态绑定</h4><p><strong>动态绑定</strong>: 在程序运行过程中，根据具体的实例对象才能具体确定哪个方法<br>动态绑定是多态性的关键，它通过方法表实现: 每个类被加载到虚拟机的时候，在方法区保存元数据，包括一个叫做**方法表(method table)**的东西，表中记录了这个类定义的方法的指针，每个表项指向一个具体的方法。</p>
<blockquote>
<p>绑定过程:<br>1.虚拟机提取对象的实际类型的方法表<br>2.虚拟机搜索方法签名<br>3.调用方法</p>
</blockquote>
<p>动态绑定发生在父子类的转换声明之下:</p>
<blockquote>
<p>Parent p = new Children();<br>p.say();<br>Children 继承自Parent，重写了say；<br>过程:</p>
</blockquote>
<ol>
<li>编译：向上转型时，用父类引用执行子类对象，并可以用父类引用调用子类中重写了的同名方法，但是不能调用子类中新增的方法; 因为在代码的编译阶段，编译器通过 声明对象的类型（即引用本身的类型） 在方法区中该类型的方法表中查找匹配的方法（最佳匹配法：参数类型最接近的被调用），如果有则编译通过。编译阶段是确保方法的正确性，保证程序能顺利安全的运行 </li>
<li>运行：我们又知道，ft.say()调用的是Son中的say()，这不就与上面说的，查找Father类的方法表的匹配方法矛盾了吗？不，这里就是动态绑定机制的真正体现、</li>
<li>上面编译阶段在 <strong>声明对象类型</strong> 的方法表中查找方法，只是为了安全地通过编译（也为了检验方法是否是存在的）。而在实际运行这条语句时，在执行 Parent p = new Children(); 这一句时创建了一个Children实例对象，然后在 <strong>p.say()</strong> 调用方法时，JVM会把刚才的son对象压入操作数栈，用它来进行调用。</li>
<li><strong>而用实例对象进行方法调用的过程就是动态绑定</strong>：根据实例对象所属的类型去查找它的方法表，找到匹配的方法进行调用。我们知道，子类中如果重写了父类的方法，则方法表中同名表项会指向子类的方法代码；若无重写，则按照父类中的方法表顺序保存在子类方法表中。故此：动态绑定根据对象的类型的方法表查找方法是一定会匹配（因为编译时在父类方法表中以及查找并匹配成功了，说明方法是存在的。这也解释了为何向上转型时父类引用不能调用子类新增的方法：在父类方法表中必须先对这个方法的存在性进行检验，如果在运行时才检验就容易出危险——可能子类中也没有这个方法）。</li>
</ol>
<h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h4><ol>
<li>程序在JVM运行过程中，会把类的类型信息，static属性和方法，final常量等元数据加载到方法区，这些在类被加载时就已经知道，不需要对象的创建就能访问就是静态绑定；</li>
<li>需要等数据创建出来，使用时根据堆中的实例对象的类型才进行取用的就是动态绑定的内容</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LHC</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
